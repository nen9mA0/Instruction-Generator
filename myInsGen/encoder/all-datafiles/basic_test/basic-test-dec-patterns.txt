#BEGIN_LEGAL
#
#Copyright (c) 2019 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  
#END_LEGAL
#################################################################
## file: xed-prefixes.txt
#################################################################

# SYNTAX:
#    conditions and input bytes |   output-mode-state and captures...


# FIXME: make ICLASS a possible field?
# Remove the segment override if any supplied, from an LEA
REMOVE_SEGMENT()::
mode16 | SEG0=XED_REG_INVALID
mode32 | SEG0=XED_REG_INVALID
mode64 | SEG0=XED_REG_INVALID
# FIXME 2007-07-10 full "otherwise" RHS's are not supported yet in decoder.
#otherwise | SEG0=XED_REG_INVALID



PREFIXES()::

# The presence of the REX itself and the REXW are state bits because
# they control decoding downstream.

#
# 64b mode prefixes
#

# rex prefixes 
mode64  0b0100 wrxb  |  XED_RESET REX=1 REXW=w REXR=r REXX=x REXB=b 

# Note that because of the REX rules, if we see a legacy prefix after
# a rex prefix, we have to ignore the rex prefix and all its captures! 
# (reset_rex). The new state bits override existing captures and state
# bits. That explains all the rex stuff.

# other prefixes

# NOTE: double denotation of f2/f3/osz.(eg f2_prefix and
# f2_refining_prefix). That 2nd allows for table lookups indexing to
# the 2B table.

mode64  0xf2 MODE_FIRST_PREFIX=0        |  XED_RESET reset_rex f2_prefix refining_f2  
mode64  0xf3 MODE_FIRST_PREFIX=0        |  XED_RESET reset_rex f3_prefix refining_f3  
mode64  0xf2 MODE_FIRST_PREFIX=1 REP=0  |  XED_RESET reset_rex f2_prefix refining_f2
mode64  0xf3 MODE_FIRST_PREFIX=1 REP=0  |  XED_RESET reset_rex f3_prefix refining_f3
mode64  0xf2 MODE_FIRST_PREFIX=1 REP!=0 |  XED_RESET reset_rex 
mode64  0xf3 MODE_FIRST_PREFIX=1 REP!=0 |  XED_RESET reset_rex 


# 2009-08-17: The 66_prefix (OSZ=1) gets zero'ed by some instructions
# that use 66 as a refining prefix. To ensure we have a 66 prefix
# indicator, we also set PREFIX66=1.
mode64  0x66  |  XED_RESET 66_prefix   PREFIX66=1 reset_rex 

mode64  0x67  |  XED_RESET 67_prefix              reset_rex 
mode64  0xf0  |  XED_RESET lock_prefix            reset_rex

#  CS and DS prefixes could be branch hints. cs_prefix and ds_prefix
#    translate to the correct values for the BRANCH_HINT nonterminal.
mode64  0x2e  |  XED_RESET HINT=1  reset_rex
mode64  0x3e  |  XED_RESET HINT=2  reset_rex

mode64  0x26  |  XED_RESET                 reset_rex
mode64  0x64  |  XED_RESET fs_prefix       reset_rex
mode64  0x65  |  XED_RESET gs_prefix       reset_rex
mode64  0x36  |  XED_RESET                 reset_rex

# 
# 32b  mode prefixes
#

mode32  0xf2 MODE_FIRST_PREFIX=0        |  XED_RESET  f2_prefix refining_f2  
mode32  0xf3 MODE_FIRST_PREFIX=0        |  XED_RESET  f3_prefix refining_f3  
mode32  0xf2 MODE_FIRST_PREFIX=1 REP=0  |  XED_RESET  f2_prefix refining_f2
mode32  0xf3 MODE_FIRST_PREFIX=1 REP=0  |  XED_RESET  f3_prefix refining_f3
mode32  0xf2 MODE_FIRST_PREFIX=1 REP!=0 |  XED_RESET  
mode32  0xf3 MODE_FIRST_PREFIX=1 REP!=0 |  XED_RESET 

mode32  0x66  |  XED_RESET 66_prefix PREFIX66=1
mode32  0x67  |  XED_RESET 67_prefix        
mode32  0xf0  |  XED_RESET lock_prefix     
#  CS and DS prefixes could be branch hints. cs_prefix and ds_prefix
#    translate to the correct values for the BRANCH_HINT nonterminal.
mode32  0x2e  |  XED_RESET cs_prefix HINT=1
mode32  0x3e  |  XED_RESET ds_prefix HINT=2

mode32  0x26  |  XED_RESET es_prefix       
mode32  0x64  |  XED_RESET fs_prefix       
mode32  0x65  |  XED_RESET gs_prefix       
mode32  0x36  |  XED_RESET ss_prefix       

# 
# 16b mode prefixes
#


mode16  0xf2 MODE_FIRST_PREFIX=0        |  XED_RESET  f2_prefix refining_f2  
mode16  0xf3 MODE_FIRST_PREFIX=0        |  XED_RESET  f3_prefix refining_f3  
mode16  0xf2 MODE_FIRST_PREFIX=1 REP=0  |  XED_RESET  f2_prefix refining_f2
mode16  0xf3 MODE_FIRST_PREFIX=1 REP=0  |  XED_RESET  f3_prefix refining_f3
mode16  0xf2 MODE_FIRST_PREFIX=1 REP!=0 |  XED_RESET  
mode16  0xf3 MODE_FIRST_PREFIX=1 REP!=0 |  XED_RESET 

mode16  0x66  |  XED_RESET 66_prefix   PREFIX66=1
mode16  0x67  |  XED_RESET 67_prefix        
mode16  0xf0  |  XED_RESET lock_prefix     
#  CS and DS prefixes could be branch hints. cs_prefix and ds_prefix
#    translate to the correct values for the BRANCH_HINT nonterminal.
mode16  0x2e  |  XED_RESET cs_prefix HINT=1      
mode16  0x3e  |  XED_RESET ds_prefix HINT=2

mode16  0x26  |  XED_RESET es_prefix       
mode16  0x64  |  XED_RESET fs_prefix       
mode16  0x65  |  XED_RESET gs_prefix       
mode16  0x36  |  XED_RESET ss_prefix       

# This is the epsilon action indicating that it is okay to 
# accept nothing at this point in the traversal.
otherwise   | 

BRANCH_HINT()::
HINT=0    | 
HINT=1    | HINT=3
HINT=2    | HINT=4

#BEGIN_LEGAL
#
#Copyright (c) 2019 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  
#END_LEGAL
########################################################################
## file: xed-reg-tables.txt
########################################################################

# Need to handle flags, rIP, seg-selectors, pseudo regs
# Also does not specify register width

# What about something like this:
#     op1=GPRv_R():rw
# we need to know what to bind the result to ultimately.
# Just specifying a register is confusing to me. Don't know where to store it.
# Have a "store-here" location for this kind of thing?

#######################################################################
# Expand the generic registers using the effective address size EASZ
#######################################################################
xed_reg_enum_t ArAX()::
EASZ=1 | OUTREG=XED_REG_AX
EASZ=2 | OUTREG=XED_REG_EAX
EASZ=3 | OUTREG=XED_REG_RAX
xed_reg_enum_t ArBX()::
EASZ=1 | OUTREG=XED_REG_BX
EASZ=2 | OUTREG=XED_REG_EBX
EASZ=3 | OUTREG=XED_REG_RBX
xed_reg_enum_t ArCX()::
EASZ=1 | OUTREG=XED_REG_CX
EASZ=2 | OUTREG=XED_REG_ECX
EASZ=3 | OUTREG=XED_REG_RCX
xed_reg_enum_t ArDX()::
EASZ=1 | OUTREG=XED_REG_DX
EASZ=2 | OUTREG=XED_REG_EDX
EASZ=3 | OUTREG=XED_REG_RDX

xed_reg_enum_t ArSI()::
EASZ=1 | OUTREG=XED_REG_SI
EASZ=2 | OUTREG=XED_REG_ESI
EASZ=3 | OUTREG=XED_REG_RSI
xed_reg_enum_t ArDI()::
EASZ=1 | OUTREG=XED_REG_DI
EASZ=2 | OUTREG=XED_REG_EDI
EASZ=3 | OUTREG=XED_REG_RDI
xed_reg_enum_t ArSP()::
EASZ=1 | OUTREG=XED_REG_SP
EASZ=2 | OUTREG=XED_REG_ESP
EASZ=3 | OUTREG=XED_REG_RSP
xed_reg_enum_t ArBP()::
EASZ=1 | OUTREG=XED_REG_BP
EASZ=2 | OUTREG=XED_REG_EBP
EASZ=3 | OUTREG=XED_REG_RBP

xed_reg_enum_t SrSP()::
smode16 | OUTREG=XED_REG_SP
smode32 | OUTREG=XED_REG_ESP
smode64 | OUTREG=XED_REG_RSP
xed_reg_enum_t SrBP()::
smode16 | OUTREG=XED_REG_BP
smode32 | OUTREG=XED_REG_EBP
smode64 | OUTREG=XED_REG_RBP

xed_reg_enum_t Ar8()::
EASZ=1 | OUTREG=XED_REG_R8W
EASZ=2 | OUTREG=XED_REG_R8D
EASZ=3 | OUTREG=XED_REG_R8
xed_reg_enum_t Ar9()::
EASZ=1 | OUTREG=XED_REG_R9W
EASZ=2 | OUTREG=XED_REG_R9D
EASZ=3 | OUTREG=XED_REG_R9
xed_reg_enum_t Ar10()::
EASZ=1 | OUTREG=XED_REG_R10W
EASZ=2 | OUTREG=XED_REG_R10D
EASZ=3 | OUTREG=XED_REG_R10
xed_reg_enum_t Ar11()::
EASZ=1 | OUTREG=XED_REG_R11W
EASZ=2 | OUTREG=XED_REG_R11D
EASZ=3 | OUTREG=XED_REG_R11
xed_reg_enum_t Ar12()::
EASZ=1 | OUTREG=XED_REG_R12W
EASZ=2 | OUTREG=XED_REG_R12D
EASZ=3 | OUTREG=XED_REG_R12
xed_reg_enum_t Ar13()::
EASZ=1 | OUTREG=XED_REG_R13W
EASZ=2 | OUTREG=XED_REG_R13D
EASZ=3 | OUTREG=XED_REG_R13
xed_reg_enum_t Ar14()::
EASZ=1 | OUTREG=XED_REG_R14W
EASZ=2 | OUTREG=XED_REG_R14D
EASZ=3 | OUTREG=XED_REG_R14
xed_reg_enum_t Ar15()::
EASZ=1 | OUTREG=XED_REG_R15W
EASZ=2 | OUTREG=XED_REG_R15D
EASZ=3 | OUTREG=XED_REG_R15

xed_reg_enum_t rIP()::
mode16 | OUTREG=XED_REG_EIP
mode32 | OUTREG=XED_REG_EIP
mode64 | OUTREG=XED_REG_RIP

xed_reg_enum_t rIPa()::
EASZ=2 | OUTREG=XED_REG_EIP
EASZ=3 | OUTREG=XED_REG_RIP

#######################################################################
# Expand the generic registers using the effective address size EOSZ - limit 32b
#######################################################################


xed_reg_enum_t OeAX()::
EOSZ=1 | OUTREG=XED_REG_AX
EOSZ=2 | OUTREG=XED_REG_EAX
EOSZ=3 | OUTREG=XED_REG_EAX


#######################################################################
# Expand the generic registers using the effective address size EOSZ - limit 64b
#######################################################################

xed_reg_enum_t OrAX()::
EOSZ=1 | OUTREG=XED_REG_AX
EOSZ=2 | OUTREG=XED_REG_EAX
EOSZ=3 | OUTREG=XED_REG_RAX
xed_reg_enum_t OrDX()::
EOSZ=1 | OUTREG=XED_REG_DX
EOSZ=2 | OUTREG=XED_REG_EDX
EOSZ=3 | OUTREG=XED_REG_RDX

# only used for VIA PADLOCK ISA:
xed_reg_enum_t OrCX()::
EOSZ=1 | OUTREG=XED_REG_CX
EOSZ=2 | OUTREG=XED_REG_ECX
EOSZ=3 | OUTREG=XED_REG_RCX
# only used for VIA PADLOCK ISA:
xed_reg_enum_t OrBX()::
EOSZ=1 | OUTREG=XED_REG_BX
EOSZ=2 | OUTREG=XED_REG_EBX
EOSZ=3 | OUTREG=XED_REG_RBX

xed_reg_enum_t OrSP()::
EOSZ=1 | OUTREG=XED_REG_SP
EOSZ=2 | OUTREG=XED_REG_ESP
EOSZ=3 | OUTREG=XED_REG_RSP
xed_reg_enum_t OrBP()::
EOSZ=1 | OUTREG=XED_REG_BP
EOSZ=2 | OUTREG=XED_REG_EBP
EOSZ=3 | OUTREG=XED_REG_RBP


#####################################################

xed_reg_enum_t rFLAGS()::
mode16 | OUTREG=XED_REG_FLAGS
mode32 | OUTREG=XED_REG_EFLAGS
mode64 | OUTREG=XED_REG_RFLAGS

#####################################################


xed_reg_enum_t MMX_R()::
REG=0x0  | OUTREG=XED_REG_MMX0
REG=0x1  | OUTREG=XED_REG_MMX1
REG=0x2  | OUTREG=XED_REG_MMX2
REG=0x3  | OUTREG=XED_REG_MMX3
REG=0x4  | OUTREG=XED_REG_MMX4
REG=0x5  | OUTREG=XED_REG_MMX5
REG=0x6  | OUTREG=XED_REG_MMX6
REG=0x7  | OUTREG=XED_REG_MMX7

xed_reg_enum_t MMX_B()::
RM=0x0  | OUTREG=XED_REG_MMX0
RM=0x1  | OUTREG=XED_REG_MMX1
RM=0x2  | OUTREG=XED_REG_MMX2
RM=0x3  | OUTREG=XED_REG_MMX3
RM=0x4  | OUTREG=XED_REG_MMX4
RM=0x5  | OUTREG=XED_REG_MMX5
RM=0x6  | OUTREG=XED_REG_MMX6
RM=0x7  | OUTREG=XED_REG_MMX7

#################################

# Things that scale with effective operand size 



# When used as the MODRM.REG register
xed_reg_enum_t GPRv_R()::
EOSZ=3 | OUTREG=GPR64_R() 
EOSZ=2 | OUTREG=GPR32_R() 
EOSZ=1 | OUTREG=GPR16_R() 

xed_reg_enum_t GPRv_SB()::
EOSZ=3 | OUTREG=GPR64_SB() 
EOSZ=2 | OUTREG=GPR32_SB() 
EOSZ=1 | OUTREG=GPR16_SB() 

xed_reg_enum_t GPRz_R()::
EOSZ=3 | OUTREG=GPR32_R() 
EOSZ=2 | OUTREG=GPR32_R() 
EOSZ=1 | OUTREG=GPR16_R() 

# When used as the MOD=11/RM register
xed_reg_enum_t GPRv_B()::
EOSZ=3 | OUTREG=GPR64_B() 
EOSZ=2 | OUTREG=GPR32_B() 
EOSZ=1 | OUTREG=GPR16_B() 

xed_reg_enum_t GPRz_B()::
EOSZ=3 | OUTREG=GPR32_B() 
EOSZ=2 | OUTREG=GPR32_B() 
EOSZ=1 | OUTREG=GPR16_B() 

xed_reg_enum_t GPRy_B()::
EOSZ=3 | OUTREG=GPR64_B() 
EOSZ=2 | OUTREG=GPR32_B() 
EOSZ=1 | OUTREG=GPR32_B() 

xed_reg_enum_t GPRy_R()::
EOSZ=3 | OUTREG=GPR64_R() 
EOSZ=2 | OUTREG=GPR32_R() 
EOSZ=1 | OUTREG=GPR32_R() 

#####################################

xed_reg_enum_t GPR64_R()::
REXR=0 REG=0x0  | OUTREG=XED_REG_RAX
REXR=0 REG=0x1  | OUTREG=XED_REG_RCX
REXR=0 REG=0x2  | OUTREG=XED_REG_RDX
REXR=0 REG=0x3  | OUTREG=XED_REG_RBX
REXR=0 REG=0x4  | OUTREG=XED_REG_RSP
REXR=0 REG=0x5  | OUTREG=XED_REG_RBP
REXR=0 REG=0x6  | OUTREG=XED_REG_RSI
REXR=0 REG=0x7  | OUTREG=XED_REG_RDI
REXR=1 REG=0x0  | OUTREG=XED_REG_R8
REXR=1 REG=0x1  | OUTREG=XED_REG_R9
REXR=1 REG=0x2  | OUTREG=XED_REG_R10
REXR=1 REG=0x3  | OUTREG=XED_REG_R11
REXR=1 REG=0x4  | OUTREG=XED_REG_R12
REXR=1 REG=0x5  | OUTREG=XED_REG_R13
REXR=1 REG=0x6  | OUTREG=XED_REG_R14
REXR=1 REG=0x7  | OUTREG=XED_REG_R15


xed_reg_enum_t GPR64_B()::
REXB=0 RM=0x0  | OUTREG=XED_REG_RAX
REXB=0 RM=0x1  | OUTREG=XED_REG_RCX
REXB=0 RM=0x2  | OUTREG=XED_REG_RDX
REXB=0 RM=0x3  | OUTREG=XED_REG_RBX
REXB=0 RM=0x4  | OUTREG=XED_REG_RSP
REXB=0 RM=0x5  | OUTREG=XED_REG_RBP
REXB=0 RM=0x6  | OUTREG=XED_REG_RSI
REXB=0 RM=0x7  | OUTREG=XED_REG_RDI
REXB=1 RM=0x0  | OUTREG=XED_REG_R8
REXB=1 RM=0x1  | OUTREG=XED_REG_R9
REXB=1 RM=0x2  | OUTREG=XED_REG_R10
REXB=1 RM=0x3  | OUTREG=XED_REG_R11
REXB=1 RM=0x4  | OUTREG=XED_REG_R12
REXB=1 RM=0x5  | OUTREG=XED_REG_R13
REXB=1 RM=0x6  | OUTREG=XED_REG_R14
REXB=1 RM=0x7  | OUTREG=XED_REG_R15

xed_reg_enum_t GPR64_SB()::
REXB=0 SRM=0x0  | OUTREG=XED_REG_RAX
REXB=0 SRM=0x1  | OUTREG=XED_REG_RCX
REXB=0 SRM=0x2  | OUTREG=XED_REG_RDX
REXB=0 SRM=0x3  | OUTREG=XED_REG_RBX
REXB=0 SRM=0x4  | OUTREG=XED_REG_RSP
REXB=0 SRM=0x5  | OUTREG=XED_REG_RBP
REXB=0 SRM=0x6  | OUTREG=XED_REG_RSI
REXB=0 SRM=0x7  | OUTREG=XED_REG_RDI
REXB=1 SRM=0x0  | OUTREG=XED_REG_R8
REXB=1 SRM=0x1  | OUTREG=XED_REG_R9
REXB=1 SRM=0x2  | OUTREG=XED_REG_R10
REXB=1 SRM=0x3  | OUTREG=XED_REG_R11
REXB=1 SRM=0x4  | OUTREG=XED_REG_R12
REXB=1 SRM=0x5  | OUTREG=XED_REG_R13
REXB=1 SRM=0x6  | OUTREG=XED_REG_R14
REXB=1 SRM=0x7  | OUTREG=XED_REG_R15



xed_reg_enum_t GPR64_X()::
REXX=0 SIBINDEX=0x0  | OUTREG=XED_REG_RAX
REXX=0 SIBINDEX=0x1  | OUTREG=XED_REG_RCX
REXX=0 SIBINDEX=0x2  | OUTREG=XED_REG_RDX
REXX=0 SIBINDEX=0x3  | OUTREG=XED_REG_RBX
REXX=0 SIBINDEX=0x4  | OUTREG=XED_REG_INVALID
REXX=0 SIBINDEX=0x5  | OUTREG=XED_REG_RBP
REXX=0 SIBINDEX=0x6  | OUTREG=XED_REG_RSI
REXX=0 SIBINDEX=0x7  | OUTREG=XED_REG_RDI
REXX=1 SIBINDEX=0x0  | OUTREG=XED_REG_R8
REXX=1 SIBINDEX=0x1  | OUTREG=XED_REG_R9
REXX=1 SIBINDEX=0x2  | OUTREG=XED_REG_R10
REXX=1 SIBINDEX=0x3  | OUTREG=XED_REG_R11
REXX=1 SIBINDEX=0x4  | OUTREG=XED_REG_R12
REXX=1 SIBINDEX=0x5  | OUTREG=XED_REG_R13
REXX=1 SIBINDEX=0x6  | OUTREG=XED_REG_R14
REXX=1 SIBINDEX=0x7  | OUTREG=XED_REG_R15


#################################


xed_reg_enum_t GPR32_R()::
REXR=0 REG=0x0  | OUTREG=XED_REG_EAX
REXR=0 REG=0x1  | OUTREG=XED_REG_ECX
REXR=0 REG=0x2  | OUTREG=XED_REG_EDX
REXR=0 REG=0x3  | OUTREG=XED_REG_EBX
REXR=0 REG=0x4  | OUTREG=XED_REG_ESP
REXR=0 REG=0x5  | OUTREG=XED_REG_EBP
REXR=0 REG=0x6  | OUTREG=XED_REG_ESI
REXR=0 REG=0x7  | OUTREG=XED_REG_EDI
REXR=1 REG=0x0  | OUTREG=XED_REG_R8D
REXR=1 REG=0x1  | OUTREG=XED_REG_R9D
REXR=1 REG=0x2  | OUTREG=XED_REG_R10D
REXR=1 REG=0x3  | OUTREG=XED_REG_R11D
REXR=1 REG=0x4  | OUTREG=XED_REG_R12D
REXR=1 REG=0x5  | OUTREG=XED_REG_R13D
REXR=1 REG=0x6  | OUTREG=XED_REG_R14D
REXR=1 REG=0x7  | OUTREG=XED_REG_R15D

xed_reg_enum_t GPR32_B()::
REXB=0 RM=0x0  | OUTREG=XED_REG_EAX
REXB=0 RM=0x1  | OUTREG=XED_REG_ECX
REXB=0 RM=0x2  | OUTREG=XED_REG_EDX
REXB=0 RM=0x3  | OUTREG=XED_REG_EBX
REXB=0 RM=0x4  | OUTREG=XED_REG_ESP
REXB=0 RM=0x5  | OUTREG=XED_REG_EBP
REXB=0 RM=0x6  | OUTREG=XED_REG_ESI
REXB=0 RM=0x7  | OUTREG=XED_REG_EDI
REXB=1 RM=0x0  | OUTREG=XED_REG_R8D
REXB=1 RM=0x1  | OUTREG=XED_REG_R9D
REXB=1 RM=0x2  | OUTREG=XED_REG_R10D
REXB=1 RM=0x3  | OUTREG=XED_REG_R11D
REXB=1 RM=0x4  | OUTREG=XED_REG_R12D
REXB=1 RM=0x5  | OUTREG=XED_REG_R13D
REXB=1 RM=0x6  | OUTREG=XED_REG_R14D
REXB=1 RM=0x7  | OUTREG=XED_REG_R15D

xed_reg_enum_t GPR32_SB()::
REXB=0 SRM=0x0  | OUTREG=XED_REG_EAX
REXB=0 SRM=0x1  | OUTREG=XED_REG_ECX
REXB=0 SRM=0x2  | OUTREG=XED_REG_EDX
REXB=0 SRM=0x3  | OUTREG=XED_REG_EBX
REXB=0 SRM=0x4  | OUTREG=XED_REG_ESP
REXB=0 SRM=0x5  | OUTREG=XED_REG_EBP
REXB=0 SRM=0x6  | OUTREG=XED_REG_ESI
REXB=0 SRM=0x7  | OUTREG=XED_REG_EDI
REXB=1 SRM=0x0  | OUTREG=XED_REG_R8D
REXB=1 SRM=0x1  | OUTREG=XED_REG_R9D
REXB=1 SRM=0x2  | OUTREG=XED_REG_R10D
REXB=1 SRM=0x3  | OUTREG=XED_REG_R11D
REXB=1 SRM=0x4  | OUTREG=XED_REG_R12D
REXB=1 SRM=0x5  | OUTREG=XED_REG_R13D
REXB=1 SRM=0x6  | OUTREG=XED_REG_R14D
REXB=1 SRM=0x7  | OUTREG=XED_REG_R15D





xed_reg_enum_t GPR32_X()::
REXX=0 SIBINDEX=0x0  | OUTREG=XED_REG_EAX
REXX=0 SIBINDEX=0x1  | OUTREG=XED_REG_ECX
REXX=0 SIBINDEX=0x2  | OUTREG=XED_REG_EDX
REXX=0 SIBINDEX=0x3  | OUTREG=XED_REG_EBX
REXX=0 SIBINDEX=0x4  | OUTREG=XED_REG_INVALID
REXX=0 SIBINDEX=0x5  | OUTREG=XED_REG_EBP
REXX=0 SIBINDEX=0x6  | OUTREG=XED_REG_ESI
REXX=0 SIBINDEX=0x7  | OUTREG=XED_REG_EDI
REXX=1 SIBINDEX=0x0  | OUTREG=XED_REG_R8D
REXX=1 SIBINDEX=0x1  | OUTREG=XED_REG_R9D
REXX=1 SIBINDEX=0x2  | OUTREG=XED_REG_R10D
REXX=1 SIBINDEX=0x3  | OUTREG=XED_REG_R11D
REXX=1 SIBINDEX=0x4  | OUTREG=XED_REG_R12D
REXX=1 SIBINDEX=0x5  | OUTREG=XED_REG_R13D
REXX=1 SIBINDEX=0x6  | OUTREG=XED_REG_R14D
REXX=1 SIBINDEX=0x7  | OUTREG=XED_REG_R15D


#############################


xed_reg_enum_t GPR16_R()::
REXR=0 REG=0x0  | OUTREG=XED_REG_AX
REXR=0 REG=0x1  | OUTREG=XED_REG_CX
REXR=0 REG=0x2  | OUTREG=XED_REG_DX
REXR=0 REG=0x3  | OUTREG=XED_REG_BX
REXR=0 REG=0x4  | OUTREG=XED_REG_SP
REXR=0 REG=0x5  | OUTREG=XED_REG_BP
REXR=0 REG=0x6  | OUTREG=XED_REG_SI
REXR=0 REG=0x7  | OUTREG=XED_REG_DI
REXR=1 REG=0x0  | OUTREG=XED_REG_R8W
REXR=1 REG=0x1  | OUTREG=XED_REG_R9W
REXR=1 REG=0x2  | OUTREG=XED_REG_R10W
REXR=1 REG=0x3  | OUTREG=XED_REG_R11W
REXR=1 REG=0x4  | OUTREG=XED_REG_R12W
REXR=1 REG=0x5  | OUTREG=XED_REG_R13W
REXR=1 REG=0x6  | OUTREG=XED_REG_R14W
REXR=1 REG=0x7  | OUTREG=XED_REG_R15W



xed_reg_enum_t GPR16_B()::
REXB=0 RM=0x0  | OUTREG=XED_REG_AX
REXB=0 RM=0x1  | OUTREG=XED_REG_CX
REXB=0 RM=0x2  | OUTREG=XED_REG_DX
REXB=0 RM=0x3  | OUTREG=XED_REG_BX
REXB=0 RM=0x4  | OUTREG=XED_REG_SP
REXB=0 RM=0x5  | OUTREG=XED_REG_BP
REXB=0 RM=0x6  | OUTREG=XED_REG_SI
REXB=0 RM=0x7  | OUTREG=XED_REG_DI
REXB=1 RM=0x0  | OUTREG=XED_REG_R8W
REXB=1 RM=0x1  | OUTREG=XED_REG_R9W
REXB=1 RM=0x2  | OUTREG=XED_REG_R10W
REXB=1 RM=0x3  | OUTREG=XED_REG_R11W
REXB=1 RM=0x4  | OUTREG=XED_REG_R12W
REXB=1 RM=0x5  | OUTREG=XED_REG_R13W
REXB=1 RM=0x6  | OUTREG=XED_REG_R14W
REXB=1 RM=0x7  | OUTREG=XED_REG_R15W

xed_reg_enum_t GPR16_SB()::
REXB=0 SRM=0x0  | OUTREG=XED_REG_AX
REXB=0 SRM=0x1  | OUTREG=XED_REG_CX
REXB=0 SRM=0x2  | OUTREG=XED_REG_DX
REXB=0 SRM=0x3  | OUTREG=XED_REG_BX
REXB=0 SRM=0x4  | OUTREG=XED_REG_SP
REXB=0 SRM=0x5  | OUTREG=XED_REG_BP
REXB=0 SRM=0x6  | OUTREG=XED_REG_SI
REXB=0 SRM=0x7  | OUTREG=XED_REG_DI
REXB=1 SRM=0x0  | OUTREG=XED_REG_R8W
REXB=1 SRM=0x1  | OUTREG=XED_REG_R9W
REXB=1 SRM=0x2  | OUTREG=XED_REG_R10W
REXB=1 SRM=0x3  | OUTREG=XED_REG_R11W
REXB=1 SRM=0x4  | OUTREG=XED_REG_R12W
REXB=1 SRM=0x5  | OUTREG=XED_REG_R13W
REXB=1 SRM=0x6  | OUTREG=XED_REG_R14W
REXB=1 SRM=0x7  | OUTREG=XED_REG_R15W



#############################

# GPR8_R and GPR8_B are handled in separate files -- grep for them.

###########################a

xed_reg_enum_t CR_R()::
REXR=0 REG=0x0  | OUTREG=XED_REG_CR0
REXR=0 REG=0x1  | OUTREG=XED_REG_ERROR  enc
REXR=0 REG=0x2  | OUTREG=XED_REG_CR2
REXR=0 REG=0x3  | OUTREG=XED_REG_CR3
REXR=0 REG=0x4  | OUTREG=XED_REG_CR4
REXR=0 REG=0x5  | OUTREG=XED_REG_ERROR
REXR=0 REG=0x6  | OUTREG=XED_REG_ERROR
REXR=0 REG=0x7  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x0  | OUTREG=XED_REG_CR8
REXR=1 REG=0x1  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x2  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x3  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x4  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x5  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x6  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x7  | OUTREG=XED_REG_ERROR

# FIXME: not used
xed_reg_enum_t CR_B()::
REXB=0 RM=0x0  | OUTREG=XED_REG_CR0
REXB=0 RM=0x1  | OUTREG=XED_REG_ERROR   enc
REXB=0 RM=0x2  | OUTREG=XED_REG_CR2
REXB=0 RM=0x3  | OUTREG=XED_REG_CR3
REXB=0 RM=0x4  | OUTREG=XED_REG_CR4
REXB=0 RM=0x5  | OUTREG=XED_REG_ERROR
REXB=0 RM=0x6  | OUTREG=XED_REG_ERROR
REXB=0 RM=0x7  | OUTREG=XED_REG_ERROR
REXB=1 RM=0x0  | OUTREG=XED_REG_CR8
REXB=1 RM=0x1  | OUTREG=XED_REG_ERROR
REXB=1 RM=0x2  | OUTREG=XED_REG_ERROR
REXB=1 RM=0x3  | OUTREG=XED_REG_ERROR
REXB=1 RM=0x4  | OUTREG=XED_REG_ERROR
REXB=1 RM=0x5  | OUTREG=XED_REG_ERROR
REXB=1 RM=0x6  | OUTREG=XED_REG_ERROR
REXB=1 RM=0x7  | OUTREG=XED_REG_ERROR

########################

xed_reg_enum_t DR_R()::
REXR=0 REG=0x0  | OUTREG=XED_REG_DR0
REXR=0 REG=0x1  | OUTREG=XED_REG_DR1
REXR=0 REG=0x2  | OUTREG=XED_REG_DR2
REXR=0 REG=0x3  | OUTREG=XED_REG_DR3
REXR=0 REG=0x4  | OUTREG=XED_REG_DR4
REXR=0 REG=0x5  | OUTREG=XED_REG_DR5
REXR=0 REG=0x6  | OUTREG=XED_REG_DR6
REXR=0 REG=0x7  | OUTREG=XED_REG_DR7
REXR=1 REG=0x0  | OUTREG=XED_REG_ERROR enc
REXR=1 REG=0x1  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x2  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x3  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x4  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x5  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x6  | OUTREG=XED_REG_ERROR
REXR=1 REG=0x7  | OUTREG=XED_REG_ERROR

#######################


xed_reg_enum_t X87()::
RM=0x0  | OUTREG=XED_REG_ST0
RM=0x1  | OUTREG=XED_REG_ST1
RM=0x2  | OUTREG=XED_REG_ST2
RM=0x3  | OUTREG=XED_REG_ST3
RM=0x4  | OUTREG=XED_REG_ST4
RM=0x5  | OUTREG=XED_REG_ST5
RM=0x6  | OUTREG=XED_REG_ST6
RM=0x7  | OUTREG=XED_REG_ST7

###################

xed_reg_enum_t SEG()::
REG=0x0  | OUTREG=XED_REG_ES
REG=0x1  | OUTREG=XED_REG_CS
REG=0x2  | OUTREG=XED_REG_SS
REG=0x3  | OUTREG=XED_REG_DS
REG=0x4  | OUTREG=XED_REG_FS
REG=0x5  | OUTREG=XED_REG_GS
REG=0x6  | OUTREG=XED_REG_ERROR     enc
REG=0x7  | OUTREG=XED_REG_ERROR

# MOV to SEG cannot load CS 
xed_reg_enum_t SEG_MOV()::
REG=0x0  | OUTREG=XED_REG_ES
REG=0x1  | OUTREG=XED_REG_ERROR
REG=0x2  | OUTREG=XED_REG_SS
REG=0x3  | OUTREG=XED_REG_DS
REG=0x4  | OUTREG=XED_REG_FS
REG=0x5  | OUTREG=XED_REG_GS
REG=0x6  | OUTREG=XED_REG_ERROR     enc
REG=0x7  | OUTREG=XED_REG_ERROR


###################################################

# We have two versions of FINAL_DSEG called FINAL_DSEG and
# FINAL_DSEG1. This is required because in the nonterminal function, I
# don't know if which memop (MEM0 or MEM1) the segment selector is
# being applied to. I set USING_DEFAULT_SEGMENT0 for MEM0 and
# USING_DEFAULT_SEGMENT1 for MEM1.


# These set USING_DEFAULT_SEGMENT0

xed_reg_enum_t FINAL_DSEG()::
mode16 | OUTREG=FINAL_DSEG_NOT64()  
mode32 | OUTREG=FINAL_DSEG_NOT64() 
mode64 | OUTREG=FINAL_DSEG_MODE64() 

xed_reg_enum_t FINAL_DSEG_NOT64()::
SEG_OVD=0 | OUTREG=XED_REG_DS  USING_DEFAULT_SEGMENT0=1 enc # default data seg
SEG_OVD=1 | OUTREG=XED_REG_CS  USING_DEFAULT_SEGMENT0=0
SEG_OVD=2 | OUTREG=XED_REG_DS  USING_DEFAULT_SEGMENT0=1 # explicit ds seg
SEG_OVD=3 | OUTREG=XED_REG_ES  USING_DEFAULT_SEGMENT0=0
SEG_OVD=4 | OUTREG=XED_REG_FS  USING_DEFAULT_SEGMENT0=0
SEG_OVD=5 | OUTREG=XED_REG_GS  USING_DEFAULT_SEGMENT0=0
SEG_OVD=6 | OUTREG=XED_REG_SS  USING_DEFAULT_SEGMENT0=0

xed_reg_enum_t FINAL_DSEG_MODE64()::
SEG_OVD=0 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1  enc
SEG_OVD=1 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1 
SEG_OVD=2 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1  
SEG_OVD=3 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1 
SEG_OVD=4 | OUTREG=XED_REG_FS      USING_DEFAULT_SEGMENT0=0 
SEG_OVD=5 | OUTREG=XED_REG_GS      USING_DEFAULT_SEGMENT0=0 
SEG_OVD=6 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1 


# These set USING_DEFAULT_SEGMENT1 

xed_reg_enum_t FINAL_DSEG1()::
mode16 | OUTREG=FINAL_DSEG1_NOT64()  
mode32 | OUTREG=FINAL_DSEG1_NOT64() 
mode64 | OUTREG=FINAL_DSEG1_MODE64() 

xed_reg_enum_t FINAL_DSEG1_NOT64()::
SEG_OVD=0 | OUTREG=XED_REG_DS  USING_DEFAULT_SEGMENT1=1 enc # default data seg
SEG_OVD=1 | OUTREG=XED_REG_CS  USING_DEFAULT_SEGMENT1=0
SEG_OVD=2 | OUTREG=XED_REG_DS  USING_DEFAULT_SEGMENT1=1 # explicit ds seg
SEG_OVD=3 | OUTREG=XED_REG_ES  USING_DEFAULT_SEGMENT1=0
SEG_OVD=4 | OUTREG=XED_REG_FS  USING_DEFAULT_SEGMENT1=0
SEG_OVD=5 | OUTREG=XED_REG_GS  USING_DEFAULT_SEGMENT1=0
SEG_OVD=6 | OUTREG=XED_REG_SS  USING_DEFAULT_SEGMENT1=0

xed_reg_enum_t FINAL_DSEG1_MODE64()::
SEG_OVD=0 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT1=1  enc
SEG_OVD=1 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT1=1 
SEG_OVD=2 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT1=1  
SEG_OVD=3 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT1=1 
SEG_OVD=4 | OUTREG=XED_REG_FS      USING_DEFAULT_SEGMENT1=0 
SEG_OVD=5 | OUTREG=XED_REG_GS      USING_DEFAULT_SEGMENT1=0 
SEG_OVD=6 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT1=1 





###################################################

# FINAL_ESEG is only called for STRING OPS and only specifies MEM0's SEG0.

xed_reg_enum_t FINAL_ESEG()::
mode16 | OUTREG=XED_REG_ES        USING_DEFAULT_SEGMENT0=1
mode32 | OUTREG=XED_REG_ES        USING_DEFAULT_SEGMENT0=1
mode64 | OUTREG=XED_REG_INVALID   USING_DEFAULT_SEGMENT0=1

xed_reg_enum_t FINAL_ESEG1()::
mode16 | OUTREG=XED_REG_ES        USING_DEFAULT_SEGMENT1=1
mode32 | OUTREG=XED_REG_ES        USING_DEFAULT_SEGMENT1=1
mode64 | OUTREG=XED_REG_INVALID   USING_DEFAULT_SEGMENT1=1

# For synthesized stack operands (see generator.py)
xed_reg_enum_t FINAL_SSEG1()::
mode16 | OUTREG=XED_REG_SS       USING_DEFAULT_SEGMENT1=1
mode32 | OUTREG=XED_REG_SS       USING_DEFAULT_SEGMENT1=1
mode64 | OUTREG=XED_REG_INVALID  USING_DEFAULT_SEGMENT1=1

# For stack operands that cannot be overridden
xed_reg_enum_t FINAL_SSEG0()::
mode16 | OUTREG=XED_REG_SS       USING_DEFAULT_SEGMENT0=1
mode32 | OUTREG=XED_REG_SS       USING_DEFAULT_SEGMENT0=1
mode64 | OUTREG=XED_REG_INVALID  USING_DEFAULT_SEGMENT0=1

# This is only called for MODRM BYTEs and they only set MEM0's SEG0.

xed_reg_enum_t FINAL_SSEG()::
mode16 | OUTREG=FINAL_SSEG_NOT64()  
mode32 | OUTREG=FINAL_SSEG_NOT64() 
mode64 | OUTREG=FINAL_SSEG_MODE64() 

xed_reg_enum_t FINAL_SSEG_NOT64()::
SEG_OVD=0 | OUTREG=XED_REG_SS  USING_DEFAULT_SEGMENT0=1     enc # default stack seg
SEG_OVD=1 | OUTREG=XED_REG_CS  USING_DEFAULT_SEGMENT0=0
SEG_OVD=2 | OUTREG=XED_REG_DS  USING_DEFAULT_SEGMENT0=0
SEG_OVD=3 | OUTREG=XED_REG_ES  USING_DEFAULT_SEGMENT0=0
SEG_OVD=4 | OUTREG=XED_REG_FS  USING_DEFAULT_SEGMENT0=0
SEG_OVD=5 | OUTREG=XED_REG_GS  USING_DEFAULT_SEGMENT0=0
SEG_OVD=6 | OUTREG=XED_REG_SS  USING_DEFAULT_SEGMENT0=1 # explicit ss seg

xed_reg_enum_t FINAL_SSEG_MODE64()::
SEG_OVD=0 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1  enc
SEG_OVD=1 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1 
SEG_OVD=2 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1  
SEG_OVD=3 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1 
SEG_OVD=4 | OUTREG=XED_REG_FS      USING_DEFAULT_SEGMENT0=0 
SEG_OVD=5 | OUTREG=XED_REG_GS      USING_DEFAULT_SEGMENT0=0 
SEG_OVD=6 | OUTREG=XED_REG_INVALID USING_DEFAULT_SEGMENT0=1 

#BEGIN_LEGAL
#
#Copyright (c) 2019 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  
#END_LEGAL
########################################################################
## file: xed-reg-tables.txt
########################################################################

xed_reg_enum_t GPR8_R()::

REXR=0 REG=0x0  | OUTREG=XED_REG_AL
REXR=0 REG=0x1  | OUTREG=XED_REG_CL
REXR=0 REG=0x2  | OUTREG=XED_REG_DL
REXR=0 REG=0x3  | OUTREG=XED_REG_BL

REXR=0 REG=0x4  REX=0   | OUTREG=XED_REG_AH
REXR=0 REG=0x5  REX=0   | OUTREG=XED_REG_CH
REXR=0 REG=0x6  REX=0   | OUTREG=XED_REG_DH 
REXR=0 REG=0x7  REX=0   | OUTREG=XED_REG_BH

REXR=0 REG=0x4  REX=1   | OUTREG=XED_REG_SPL
REXR=0 REG=0x5  REX=1   | OUTREG=XED_REG_BPL
REXR=0 REG=0x6  REX=1   | OUTREG=XED_REG_SIL
REXR=0 REG=0x7  REX=1   | OUTREG=XED_REG_DIL

REXR=1 REG=0x0  | OUTREG=XED_REG_R8B
REXR=1 REG=0x1  | OUTREG=XED_REG_R9B
REXR=1 REG=0x2  | OUTREG=XED_REG_R10B
REXR=1 REG=0x3  | OUTREG=XED_REG_R11B
REXR=1 REG=0x4  | OUTREG=XED_REG_R12B
REXR=1 REG=0x5  | OUTREG=XED_REG_R13B
REXR=1 REG=0x6  | OUTREG=XED_REG_R14B
REXR=1 REG=0x7  | OUTREG=XED_REG_R15B

xed_reg_enum_t GPR8_B()::
REXB=0 RM=0x0  | OUTREG=XED_REG_AL 
REXB=0 RM=0x1  | OUTREG=XED_REG_CL
REXB=0 RM=0x2  | OUTREG=XED_REG_DL
REXB=0 RM=0x3  | OUTREG=XED_REG_BL

REXB=0 RM=0x4  REX=0  | OUTREG=XED_REG_AH
REXB=0 RM=0x5  REX=0  | OUTREG=XED_REG_CH
REXB=0 RM=0x6  REX=0  | OUTREG=XED_REG_DH
REXB=0 RM=0x7  REX=0  | OUTREG=XED_REG_BH

REXB=0 RM=0x4  REX=1  | OUTREG=XED_REG_SPL
REXB=0 RM=0x5  REX=1  | OUTREG=XED_REG_BPL
REXB=0 RM=0x6  REX=1  | OUTREG=XED_REG_SIL
REXB=0 RM=0x7  REX=1  | OUTREG=XED_REG_DIL

REXB=1 RM=0x0  | OUTREG=XED_REG_R8B
REXB=1 RM=0x1  | OUTREG=XED_REG_R9B
REXB=1 RM=0x2  | OUTREG=XED_REG_R10B
REXB=1 RM=0x3  | OUTREG=XED_REG_R11B
REXB=1 RM=0x4  | OUTREG=XED_REG_R12B
REXB=1 RM=0x5  | OUTREG=XED_REG_R13B
REXB=1 RM=0x6  | OUTREG=XED_REG_R14B
REXB=1 RM=0x7  | OUTREG=XED_REG_R15B


xed_reg_enum_t GPR8_SB()::
REXB=0 SRM=0x0  | OUTREG=XED_REG_AL 
REXB=0 SRM=0x1  | OUTREG=XED_REG_CL
REXB=0 SRM=0x2  | OUTREG=XED_REG_DL
REXB=0 SRM=0x3  | OUTREG=XED_REG_BL

REXB=0 SRM=0x4  REX=0  | OUTREG=XED_REG_AH
REXB=0 SRM=0x5  REX=0  | OUTREG=XED_REG_CH
REXB=0 SRM=0x6  REX=0  | OUTREG=XED_REG_DH
REXB=0 SRM=0x7  REX=0  | OUTREG=XED_REG_BH

REXB=0 SRM=0x4  REX=1  | OUTREG=XED_REG_SPL
REXB=0 SRM=0x5  REX=1  | OUTREG=XED_REG_BPL
REXB=0 SRM=0x6  REX=1  | OUTREG=XED_REG_SIL
REXB=0 SRM=0x7  REX=1  | OUTREG=XED_REG_DIL

REXB=1 SRM=0x0  | OUTREG=XED_REG_R8B
REXB=1 SRM=0x1  | OUTREG=XED_REG_R9B
REXB=1 SRM=0x2  | OUTREG=XED_REG_R10B
REXB=1 SRM=0x3  | OUTREG=XED_REG_R11B
REXB=1 SRM=0x4  | OUTREG=XED_REG_R12B
REXB=1 SRM=0x5  | OUTREG=XED_REG_R13B
REXB=1 SRM=0x6  | OUTREG=XED_REG_R14B
REXB=1 SRM=0x7  | OUTREG=XED_REG_R15B

#BEGIN_LEGAL
#
#Copyright (c) 2019 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  
#END_LEGAL
###########################################################################
## file: xed-eOSZ.txt
###########################################################################

OSZ_NONTERM()::

mode16 no66_prefix | EOSZ=1
mode16   66_prefix | EOSZ=2

mode32   66_prefix | EOSZ=1
mode32 no66_prefix | EOSZ=2

# NOTE this can get overridden later if a DF64 NT shows up.
mode64   66_prefix REXW=0 | EOSZ=1
mode64 no66_prefix REXW=0 | EOSZ=2
mode64   66_prefix REXW=1 | EOSZ=3
mode64 no66_prefix REXW=1 | EOSZ=3


# Things that default to 64b mode invoke this nonterminal once they
# are identified to denote that fact. Placement of this nonterminal is
# critical for those operations and the ones the might collide with
# during decoding. See PUSHF/PUSHFD/PUSHFQ.
#
# Denote the DF64=1 (df64).
DF64()::
mode16                     |
mode32                     |
mode64   66_prefix REXW=0  | EOSZ=1 df64
mode64 no66_prefix REXW=0  | EOSZ=3 df64
mode64   66_prefix REXW=1  | EOSZ=3 df64
mode64 no66_prefix REXW=1  | EOSZ=3 df64

# if we have a refining OSZ 0x66 prefix, then we must undo the effects
# of the OSZ_NONTERM(). DF64 is not used with anything that has refining 66 prefixes.
# We turn off the osze prefix because it is really behaving like a refining prefix for these instructions.
REFINING66()::
mode16        | EOSZ=1 no66_prefix
mode32        | EOSZ=2 no66_prefix
mode64 REXW=0 | EOSZ=2 no66_prefix
mode64 REXW=1 | EOSZ=3 no66_prefix

IGNORE66()::
mode16         | EOSZ=1 no66_prefix
mode32         | EOSZ=2 no66_prefix
mode64 REXW=0  | EOSZ=2 no66_prefix
mode64 REXW=1  | EOSZ=3 no66_prefix


# IMMUNE66() is used to make 16b mode behave like 32b mode.
# Used for:
#   cmpxchg8b / cmpxchg16b,
#   NHM sttni instr:  pcmpestri, pcmpistrm, pcmpestrm, pcmpistri,
#   BDW adox, adcx.
#
IMMUNE66()::
mode16          | EOSZ=2 no66_prefix
mode32          | EOSZ=2 no66_prefix
mode64 REXW=0   | EOSZ=2 no66_prefix
mode64 REXW=1   | EOSZ=3 no66_prefix

# Used for for CRs and DRs.
CR_WIDTH():: 
mode16  | EOSZ=2 DF32=1 no66_prefix
mode32  | EOSZ=2 DF32=1 no66_prefix
mode64  | EOSZ=3 DF64=1 no66_prefix


IMMUNE66_LOOP64()::
mode16  | 
mode32  | 
mode64  | EOSZ=3 no66_prefix

IMMUNE_REXW()::
mode16                   | 
mode32                   | 
mode64 no66_prefix       | EOSZ=2 
mode64 66_prefix REXW=1  | EOSZ=2
mode64 66_prefix REXW=0  | EOSZ=1

# FORCE64() can only be used with mode64 stuff (else encode does not
# work).  see IMMUNE66_LOOP64() for something that works in all modes.
FORCE64()::
mode64    | EOSZ=3 no66_prefix
otherwise | 
#BEGIN_LEGAL
#
#Copyright (c) 2019 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  
#END_LEGAL
###########################################################################
## file: xed-eASZ.txt
###########################################################################
# Call this after all legacy prefixes and before every instruction!


ASZ_NONTERM()::

mode16 no67_prefix  | eamode16
mode16   67_prefix  | eamode32

mode32 no67_prefix  | eamode32
mode32   67_prefix  | eamode16

mode64 no67_prefix  | eamode64
mode64   67_prefix  | eamode32
#BEGIN_LEGAL
#
#Copyright (c) 2019 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  
#END_LEGAL
###########################################################################
## file: xed-immediates.txt
###########################################################################
# Immediates and displacements
# FIXME: when there are multiple immediates, need separate storage
# FIXME: record the width of the immediate

# FIXME: for encode we'll sometimes have to choose between SIMMv and
#        SIMMz to pick a MOV, for 16 and 32b widths.
##########################################################################################
## 2-BYTE STORAGE UNITS
##########################################################################################

ONE()::
mode16  | IMM_WIDTH=8 UIMM0=1
mode32  | IMM_WIDTH=8 UIMM0=1
mode64  | IMM_WIDTH=8 UIMM0=1


UIMMv()::
EOSZ=1 UIMM0[i/16] | IMM_WIDTH=16
EOSZ=2 UIMM0[i/32] | IMM_WIDTH=32
EOSZ=3 UIMM0[i/64] | IMM_WIDTH=64

SIMMz()::
EOSZ=1 UIMM0[i/16] | IMM_WIDTH=16 IMM0SIGNED=1
EOSZ=2 UIMM0[i/32] | IMM_WIDTH=32 IMM0SIGNED=1
EOSZ=3 UIMM0[i/32] | IMM_WIDTH=32 IMM0SIGNED=1

SIMM8()::
 UIMM0[i/8] | IMM_WIDTH=8 IMM0SIGNED=1

UIMM8()::
 UIMM0[i/8] | IMM_WIDTH=8

# For ENTER. separate storage.
UIMM8_1()::
 UIMM1[i/8] | true

UIMM16()::
 UIMM0[i/16] | IMM_WIDTH=16

UIMM32()::
 UIMM0[i/32]  | IMM_WIDTH=32

BRDISP8()::
 DISP[d/8]  |BRDISP_WIDTH=8

BRDISP32()::
 DISP[d/32] |  BRDISP_WIDTH=32

BRDISPz()::
EOSZ=1 DISP[d/16]  | BRDISP_WIDTH=16
EOSZ=2 DISP[d/32]  | BRDISP_WIDTH=32
EOSZ=3 DISP[d/32]  | BRDISP_WIDTH=32

 
MEMDISPv()::
EASZ=1 DISP[a/16]  | DISP_WIDTH=16 
EASZ=2 DISP[a/32]  | DISP_WIDTH=32
EASZ=3 DISP[a/64]  | DISP_WIDTH=64 


MEMDISP32()::
DISP[a/32] | DISP_WIDTH=32

MEMDISP16()::
DISP[a/16] | DISP_WIDTH=16

MEMDISP8()::
DISP[a/8]  | DISP_WIDTH=8


MEMDISP()::
NEED_MEMDISP=0               | DISP_WIDTH=0
NEED_MEMDISP=8   DISP[a/8]   | DISP_WIDTH=8
NEED_MEMDISP=16  DISP[a/16]  | DISP_WIDTH=16
NEED_MEMDISP=32  DISP[a/32]  | DISP_WIDTH=32

#BEGIN_LEGAL
#
#Copyright (c) 2019 Intel Corporation
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
#  
#END_LEGAL
###########################################################################
## file: xed-addressing-modes-new.txt
###########################################################################

# inputs:
# REX = REX or NOREX
# REXB = REXB0 or REXB1
# REXX = REXX0 or REXX1
# MODE =  MODE32 or MODE64

# outputs:
# SEG0, BASE0, INDEX, SCALE, DISP and
# a register id to be evaluated at a higher level

# The 32b and 64b share SIB/SIB_BASE0 productions. The registers there
# have to be converted to the right width. Similarly, the rAX'es etc
# in the MODRM64alt32 need to be scaled by ASZ. So rAX is either RAX
# or EAX and r15 is either R15 or R15D depending on ASZ.

# Sooo. for the BASE0/SIB_BASE0,INDEX, we need a lookup like:
#                 base_or_index_reg_lookup(rex,rexb/x,RM,mode,asz)
# The ASZ operand will do different things. In 32b mode it is not used
# because the ASZ would take use to 16 mode addressing. In 64b mode,
# it tells use to use 64 or 32b registers. 




############################################################################
MODRM():: 
#
# NOTE: the RIP handling in 64b mode with effective addressing of 32b
# is different than the 32b addressing in 32b mode when MODRM.MOD=00_
# and MODRM.RM=101, where it is just #a base, not RIP relative.
#
mode64 eamode64   MODRM64alt32() MEMDISP() | 
mode64 eamode32   MODRM64alt32() MEMDISP() | 
mode32 eamode32   MODRM32()      MEMDISP() | 
mode32 eamode16   MODRM16()      MEMDISP() | 
mode16 eamode32   MODRM32()      MEMDISP() | 
mode16 eamode16   MODRM16()      MEMDISP() | 


############################################################################

MODRM64alt32()::
 REXB=0    MOD=0b00 RM=0b000    |  BASE0=ArAX() SEG0=FINAL_DSEG()
 REXB=1    MOD=0b00 RM=0b000    |  BASE0=Ar8()  SEG0=FINAL_DSEG()

 REXB=0    MOD=0b00 RM=0b001    |  BASE0=ArCX() SEG0=FINAL_DSEG()
 REXB=1    MOD=0b00 RM=0b001    |  BASE0=Ar9()  SEG0=FINAL_DSEG()

 REXB=0    MOD=0b00 RM=0b010    |  BASE0=ArDX() SEG0=FINAL_DSEG()
 REXB=1    MOD=0b00 RM=0b010    |  BASE0=Ar10() SEG0=FINAL_DSEG()

 REXB=0    MOD=0b00 RM=0b011    |  BASE0=ArBX() SEG0=FINAL_DSEG()
 REXB=1    MOD=0b00 RM=0b011    |  BASE0=Ar11() SEG0=FINAL_DSEG()

 REXB=0    MOD=0b00 RM=0b100   SIB()  |  
 REXB=1    MOD=0b00 RM=0b100   SIB()  | 

# Ignores rexb -- must duplicate to avoid don't-care problems
 REXB=0    MOD=0b00 RM=0b101   | NEED_MEMDISP=32   BASE0=rIPa() SEG0=FINAL_DSEG() enc
 REXB=1    MOD=0b00 RM=0b101   | NEED_MEMDISP=32   BASE0=rIPa() SEG0=FINAL_DSEG()

 REXB=0    MOD=0b00 RM=0b110    |  BASE0=ArSI() SEG0=FINAL_DSEG()
 REXB=1    MOD=0b00 RM=0b110    |  BASE0=Ar14() SEG0=FINAL_DSEG()

 REXB=0    MOD=0b00 RM=0b111    |  BASE0=ArDI() SEG0=FINAL_DSEG()
 REXB=1    MOD=0b00 RM=0b111    |  BASE0=Ar15() SEG0=FINAL_DSEG()

############################################

 REXB=0    MOD=0b01 RM=0b000   | NEED_MEMDISP=8   BASE0=ArAX() SEG0=FINAL_DSEG() 
 REXB=1    MOD=0b01 RM=0b000   | NEED_MEMDISP=8   BASE0=Ar8()  SEG0=FINAL_DSEG() 

 REXB=0    MOD=0b01 RM=0b001   | NEED_MEMDISP=8   BASE0=ArCX() SEG0=FINAL_DSEG() 
 REXB=1    MOD=0b01 RM=0b001   | NEED_MEMDISP=8   BASE0=Ar9()  SEG0=FINAL_DSEG() 

 REXB=0    MOD=0b01 RM=0b010   | NEED_MEMDISP=8   BASE0=ArDX() SEG0=FINAL_DSEG() 
 REXB=1    MOD=0b01 RM=0b010   | NEED_MEMDISP=8   BASE0=Ar10() SEG0=FINAL_DSEG() 

 REXB=0    MOD=0b01 RM=0b011   | NEED_MEMDISP=8   BASE0=ArBX() SEG0=FINAL_DSEG() 
 REXB=1    MOD=0b01 RM=0b011   | NEED_MEMDISP=8   BASE0=Ar11() SEG0=FINAL_DSEG() 

 REXB=0    MOD=0b01 RM=0b100   SIB() | NEED_MEMDISP=8     
 REXB=1    MOD=0b01 RM=0b100   SIB() | NEED_MEMDISP=8     

 REXB=0    MOD=0b01 RM=0b101   | NEED_MEMDISP=8   BASE0=ArBP() SEG0=FINAL_SSEG() 
 REXB=1    MOD=0b01 RM=0b101   | NEED_MEMDISP=8   BASE0=Ar13() SEG0=FINAL_DSEG() 

 REXB=0    MOD=0b01 RM=0b110   | NEED_MEMDISP=8   BASE0=ArSI() SEG0=FINAL_DSEG() 
 REXB=1    MOD=0b01 RM=0b110   | NEED_MEMDISP=8   BASE0=Ar14() SEG0=FINAL_DSEG() 

 REXB=0    MOD=0b01 RM=0b111   | NEED_MEMDISP=8   BASE0=ArDI() SEG0=FINAL_DSEG() 
 REXB=1    MOD=0b01 RM=0b111   | NEED_MEMDISP=8   BASE0=Ar15() SEG0=FINAL_DSEG() 


############################################

 REXB=0     MOD=0b10 RM=0b000   | NEED_MEMDISP=32   BASE0=ArAX() SEG0=FINAL_DSEG() 
 REXB=1     MOD=0b10 RM=0b000   | NEED_MEMDISP=32   BASE0=Ar8() SEG0=FINAL_DSEG() 

 REXB=0     MOD=0b10 RM=0b001   | NEED_MEMDISP=32   BASE0=ArCX() SEG0=FINAL_DSEG() 
 REXB=1     MOD=0b10 RM=0b001   | NEED_MEMDISP=32   BASE0=Ar9() SEG0=FINAL_DSEG() 

 REXB=0     MOD=0b10 RM=0b010   | NEED_MEMDISP=32   BASE0=ArDX() SEG0=FINAL_DSEG() 
 REXB=1     MOD=0b10 RM=0b010   | NEED_MEMDISP=32   BASE0=Ar10() SEG0=FINAL_DSEG() 

 REXB=0     MOD=0b10 RM=0b011   | NEED_MEMDISP=32   BASE0=ArBX() SEG0=FINAL_DSEG() 
 REXB=1     MOD=0b10 RM=0b011   | NEED_MEMDISP=32   BASE0=Ar11() SEG0=FINAL_DSEG() 

 REXB=0     MOD=0b10 RM=0b100   SIB() | NEED_MEMDISP=32    
 REXB=1     MOD=0b10 RM=0b100   SIB() | NEED_MEMDISP=32    

 REXB=0     MOD=0b10 RM=0b101   | NEED_MEMDISP=32   BASE0=ArBP() SEG0=FINAL_SSEG() 
 REXB=1     MOD=0b10 RM=0b101   | NEED_MEMDISP=32   BASE0=Ar13() SEG0=FINAL_DSEG() 

 REXB=0     MOD=0b10 RM=0b110   | NEED_MEMDISP=32   BASE0=ArSI() SEG0=FINAL_DSEG() 
 REXB=1     MOD=0b10 RM=0b110   | NEED_MEMDISP=32   BASE0=Ar14() SEG0=FINAL_DSEG() 

 REXB=0     MOD=0b10 RM=0b111   | NEED_MEMDISP=32   BASE0=ArDI() SEG0=FINAL_DSEG() 
 REXB=1     MOD=0b10 RM=0b111   | NEED_MEMDISP=32   BASE0=Ar15() SEG0=FINAL_DSEG() 

############################################


MODRM32()::
   MOD=0b00 RM=0b000    |  BASE0=XED_REG_EAX SEG0=FINAL_DSEG()
   MOD=0b00 RM=0b001    |  BASE0=XED_REG_ECX SEG0=FINAL_DSEG()
   MOD=0b00 RM=0b010    |  BASE0=XED_REG_EDX SEG0=FINAL_DSEG()
   MOD=0b00 RM=0b011    |  BASE0=XED_REG_EBX SEG0=FINAL_DSEG()
   MOD=0b00 RM=0b100   SIB()  |  
   MOD=0b00 RM=0b101   | NEED_MEMDISP=32    SEG0=FINAL_DSEG() 
   MOD=0b00 RM=0b110    |  BASE0=XED_REG_ESI SEG0=FINAL_DSEG()
   MOD=0b00 RM=0b111    |  BASE0=XED_REG_EDI SEG0=FINAL_DSEG()
####################################
   MOD=0b01 RM=0b000   | NEED_MEMDISP=8   BASE0=XED_REG_EAX SEG0=FINAL_DSEG() 
   MOD=0b01 RM=0b001   | NEED_MEMDISP=8   BASE0=XED_REG_ECX SEG0=FINAL_DSEG() 
   MOD=0b01 RM=0b010   | NEED_MEMDISP=8   BASE0=XED_REG_EDX SEG0=FINAL_DSEG() 
   MOD=0b01 RM=0b011   | NEED_MEMDISP=8   BASE0=XED_REG_EBX SEG0=FINAL_DSEG() 
   MOD=0b01 RM=0b100   SIB() | NEED_MEMDISP=8     
   MOD=0b01 RM=0b101   | NEED_MEMDISP=8   BASE0=XED_REG_EBP SEG0=FINAL_SSEG() 
   MOD=0b01 RM=0b110   | NEED_MEMDISP=8   BASE0=XED_REG_ESI SEG0=FINAL_DSEG() 
   MOD=0b01 RM=0b111   | NEED_MEMDISP=8   BASE0=XED_REG_EDI SEG0=FINAL_DSEG() 
####################################
   MOD=0b10 RM=0b000   | NEED_MEMDISP=32   BASE0=XED_REG_EAX SEG0=FINAL_DSEG() 
   MOD=0b10 RM=0b001   | NEED_MEMDISP=32   BASE0=XED_REG_ECX SEG0=FINAL_DSEG() 
   MOD=0b10 RM=0b010   | NEED_MEMDISP=32   BASE0=XED_REG_EDX SEG0=FINAL_DSEG() 
   MOD=0b10 RM=0b011   | NEED_MEMDISP=32   BASE0=XED_REG_EBX SEG0=FINAL_DSEG() 
   MOD=0b10 RM=0b100   SIB() | NEED_MEMDISP=32    
   MOD=0b10 RM=0b101   | NEED_MEMDISP=32   BASE0=XED_REG_EBP SEG0=FINAL_SSEG() 
   MOD=0b10 RM=0b110   | NEED_MEMDISP=32   BASE0=XED_REG_ESI SEG0=FINAL_DSEG() 
   MOD=0b10 RM=0b111   | NEED_MEMDISP=32   BASE0=XED_REG_EDI SEG0=FINAL_DSEG() 
############################################



###################################################
# 16 bit addressing MODRM bytes
MODRM16()::
   MOD=0b00 RM=0b000    |  BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_SI SCALE=1
   MOD=0b00 RM=0b001    |  BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_DI SCALE=1

   MOD=0b00 RM=0b010    |  BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_SI SCALE=1
   MOD=0b00 RM=0b011    |  BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_DI SCALE=1

   MOD=0b00 RM=0b100    |  BASE0=XED_REG_SI  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID
   MOD=0b00 RM=0b101    |  BASE0=XED_REG_DI  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID

   MOD=0b00 RM=0b110    | NEED_MEMDISP=16   BASE0=XED_REG_INVALID  SEG0=FINAL_DSEG()  INDEX=XED_REG_INVALID
   MOD=0b00 RM=0b111    |  BASE0=XED_REG_BX SEG0=FINAL_DSEG()  INDEX=XED_REG_INVALID

#############################################

   MOD=0b01 RM=0b000   | NEED_MEMDISP=8   BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_SI SCALE=1
   MOD=0b01 RM=0b001   | NEED_MEMDISP=8   BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_DI SCALE=1

   MOD=0b01 RM=0b010   | NEED_MEMDISP=8   BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_SI SCALE=1
   MOD=0b01 RM=0b011   | NEED_MEMDISP=8   BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_DI SCALE=1

   MOD=0b01 RM=0b100   | NEED_MEMDISP=8   BASE0=XED_REG_SI  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID 
   MOD=0b01 RM=0b101   | NEED_MEMDISP=8   BASE0=XED_REG_DI  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID 

   MOD=0b01 RM=0b110   | NEED_MEMDISP=8   BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_INVALID 
   MOD=0b01 RM=0b111   | NEED_MEMDISP=8   BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID 


#############################################
   MOD=0b10 RM=0b000   | NEED_MEMDISP=16   BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_SI SCALE=1
   MOD=0b10 RM=0b001   | NEED_MEMDISP=16   BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_DI SCALE=1

   MOD=0b10 RM=0b010   | NEED_MEMDISP=16   BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_SI SCALE=1
   MOD=0b10 RM=0b011   | NEED_MEMDISP=16   BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_DI SCALE=1

   MOD=0b10 RM=0b100   | NEED_MEMDISP=16   BASE0=XED_REG_SI  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID 
   MOD=0b10 RM=0b101   | NEED_MEMDISP=16   BASE0=XED_REG_DI  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID 

   MOD=0b10 RM=0b110   | NEED_MEMDISP=16   BASE0=XED_REG_BP  SEG0=FINAL_SSEG() INDEX=XED_REG_INVALID 
   MOD=0b10 RM=0b111   | NEED_MEMDISP=16   BASE0=XED_REG_BX  SEG0=FINAL_DSEG() INDEX=XED_REG_INVALID 
############################################

SIB()::

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArAX() SCALE=1 
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar8()  SCALE=1 

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArCX() SCALE=1 
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar9()  SCALE=1 

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDX() SCALE=1 
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar10() SCALE=1 

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBX() SCALE=1 
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar11() SCALE=1 

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=XED_REG_INVALID  SCALE=1  enc
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar12() SCALE=1 

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBP() SCALE=1 
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar13() SCALE=1 

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArSI() SCALE=1 
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar14() SCALE=1 

 REXX=0      SIBSCALE[0b00] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDI() SCALE=1 
 REXX=1      SIBSCALE[0b00] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar15() SCALE=1 




 REXX=0      SIBSCALE[0b01] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArAX() SCALE=2 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar8()  SCALE=2 

 REXX=0      SIBSCALE[0b01] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArCX() SCALE=2 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar9()  SCALE=2 

 REXX=0      SIBSCALE[0b01] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDX() SCALE=2 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar10() SCALE=2 

 REXX=0      SIBSCALE[0b01] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBX() SCALE=2 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar11() SCALE=2 


 REXX=0      SIBSCALE[0b01] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=XED_REG_INVALID  SCALE=1 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar12() SCALE=2 

 REXX=0      SIBSCALE[0b01] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBP() SCALE=2 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar13() SCALE=2 

 REXX=0      SIBSCALE[0b01] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArSI() SCALE=2 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar14() SCALE=2 

 REXX=0      SIBSCALE[0b01] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDI() SCALE=2 
 REXX=1      SIBSCALE[0b01] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar15() SCALE=2 





 REXX=0      SIBSCALE[0b10] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArAX() SCALE=4 
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar8()  SCALE=4 

 REXX=0      SIBSCALE[0b10] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArCX() SCALE=4 
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar9()  SCALE=4 

 REXX=0      SIBSCALE[0b10] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDX() SCALE=4 
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar10() SCALE=4 

 REXX=0      SIBSCALE[0b10] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBX() SCALE=4 
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar11() SCALE=4 


 REXX=0      SIBSCALE[0b10] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=XED_REG_INVALID  SCALE=1  
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar12() SCALE=4 

 REXX=0      SIBSCALE[0b10] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBP() SCALE=4  
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar13() SCALE=4 

 REXX=0      SIBSCALE[0b10] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArSI() SCALE=4  
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar14() SCALE=4 

 REXX=0      SIBSCALE[0b10] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDI() SCALE=4  
 REXX=1      SIBSCALE[0b10] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar15() SCALE=4 





 REXX=0      SIBSCALE[0b11] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArAX() SCALE=8 
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b000] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar8()  SCALE=8 

 REXX=0      SIBSCALE[0b11] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArCX() SCALE=8 
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b001] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar9()  SCALE=8 

 REXX=0      SIBSCALE[0b11] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDX() SCALE=8 
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b010] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar10() SCALE=8 

 REXX=0      SIBSCALE[0b11] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBX() SCALE=8 
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b011] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar11() SCALE=8 


 REXX=0      SIBSCALE[0b11] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=XED_REG_INVALID  SCALE=1  
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b100] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar12() SCALE=8 

 REXX=0      SIBSCALE[0b11] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArBP() SCALE=8  
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b101] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar13() SCALE=8 

 REXX=0      SIBSCALE[0b11] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArSI() SCALE=8  
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b110] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar14() SCALE=8 

 REXX=0      SIBSCALE[0b11] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=ArDI() SCALE=8  
 REXX=1      SIBSCALE[0b11] SIBINDEX[0b111] SIBBASE[bbb] SIB_BASE0()  |  INDEX=Ar15() SCALE=8 


###################################################

SIB_BASE0()::

 REXB=0    SIBBASE=0b000     |   BASE0=ArAX() SEG0=FINAL_DSEG()
 REXB=1    SIBBASE=0b000     |   BASE0=Ar8()  SEG0=FINAL_DSEG()
 REXB=0    SIBBASE=0b001     |   BASE0=ArCX() SEG0=FINAL_DSEG()
 REXB=1    SIBBASE=0b001     |   BASE0=Ar9()  SEG0=FINAL_DSEG()
			          
 REXB=0    SIBBASE=0b010     |   BASE0=ArDX() SEG0=FINAL_DSEG()
 REXB=1    SIBBASE=0b010     |   BASE0=Ar10() SEG0=FINAL_DSEG()
			          
 REXB=0    SIBBASE=0b011     |   BASE0=ArBX() SEG0=FINAL_DSEG()
 REXB=1    SIBBASE=0b011     |   BASE0=Ar11() SEG0=FINAL_DSEG()
			          
 REXB=0    SIBBASE=0b100     |   BASE0=ArSP() SEG0=FINAL_SSEG()
 REXB=1    SIBBASE=0b100     |   BASE0=Ar12() SEG0=FINAL_DSEG()

# FIXME the d/8 for MOD=01_ and d/32 for MOD=10_ case are redundantly
# specified in the manuals. I removed them from here, but the d/32 for
# MOD=00_ is required as it is unique.

# I redunantly specify DISP_WIDTH=8 or DISPWITH=32 for the MOD=01_ and
# MOD=10_ cases so that the encoder will pick the right one even though we
# accept the displacment at a higher level.

 REXB=0 SIBBASE=0b101  MOD=0b00 | NEED_MEMDISP=32  BASE0=XED_REG_INVALID SEG0=FINAL_DSEG() enc
 REXB=0 SIBBASE=0b101  MOD=0b01      | BASE0=ArBP() SEG0=FINAL_SSEG() DISP_WIDTH=8
 REXB=0 SIBBASE=0b101  MOD=0b10      | BASE0=ArBP() SEG0=FINAL_SSEG() DISP_WIDTH=32
			          
 REXB=1 SIBBASE=0b101  MOD=0b00 | NEED_MEMDISP=32  BASE0=XED_REG_INVALID SEG0=FINAL_DSEG() 
 REXB=1 SIBBASE=0b101  MOD=0b01      | BASE0=Ar13() SEG0=FINAL_DSEG() DISP_WIDTH=8
 REXB=1 SIBBASE=0b101  MOD=0b10      | BASE0=Ar13() SEG0=FINAL_DSEG() DISP_WIDTH=32
			          
 REXB=0 SIBBASE=0b110     |   BASE0=ArSI() SEG0=FINAL_DSEG()
 REXB=1 SIBBASE=0b110     |   BASE0=Ar14() SEG0=FINAL_DSEG()
	      	          
 REXB=0 SIBBASE=0b111     |   BASE0=ArDI() SEG0=FINAL_DSEG()
 REXB=1 SIBBASE=0b111     |   BASE0=Ar15() SEG0=FINAL_DSEG()

#FIXME: 2008-10-01 make these in to nops!
OVERRIDE_SEG0()::
mode16 | 
mode32 | 
mode64 | 

OVERRIDE_SEG1()::
mode16 | 
mode32 | 
mode64 | 
